animations {
    slowdown 2.000000
    window-close {
        duration-ms 250
        curve "linear"
        custom-shader "                   vec4 fall_and_rotate(vec3 coords_geo, vec3 size_geo) {\n                   float progress = niri_clamped_progress * niri_clamped_progress;\n                   vec2 coords = (coords_geo.xy - vec2(0.5, 1.0)) * size_geo.xy;\n                   coords.y -= progress * 1440.0;\n                   float random = (niri_random_seed - 0.5) / 2.0;\n                   random = sign(random) - random;\n                   float max_angle = 0.5 * random;\n                   float angle = progress * max_angle;\n                   mat2 rotate = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n                   coords = rotate * coords;\n                   coords_geo = vec3(coords / size_geo.xy + vec2(0.5, 1.0), 1.0);\n                   vec3 coords_tex = niri_geo_to_tex * coords_geo;\n                   vec4 color = texture2D(niri_tex, coords_tex.st);\n\n                   return color;\n}\n\n                   vec4 close_color(vec3 coords_geo, vec3 size_geo) {\n                   return fall_and_rotate(coords_geo, size_geo);\n   }\n\n\n"
    }
    window-open {
        duration-ms 200
        curve "linear"
        custom-shader "                    vec4 expanding_circle(vec3 coords_geo, vec3 size_geo) {\n                    vec3 coords_tex = niri_geo_to_tex * coords_geo;\n                    vec4 color = texture2D(niri_tex, coords_tex.st);\n                    vec2 coords = (coords_geo.xy - vec2(0.5, 0.5)) * size_geo.xy * 2.0;\n                    coords = coords / length(size_geo.xy);\n                    float p = niri_clamped_progress;\n                    if (p * p <= dot(coords, coords))\n                    color = vec4(0.0);\n\n  return color;\n}\n                   vec4 open_color(vec3 coords_geo, vec3 size_geo) {\n                   return expanding_circle(coords_geo, size_geo);\n  }\n"
    }
    window-resize {
        duration-ms 250
        curve "linear"
        custom-shader "  vec4 resize_color(vec3 coords_curr_geo, vec3 size_curr_geo) {\n  vec3 coords_next_geo = niri_curr_geo_to_next_geo * coords_curr_geo;\n\n  vec3 coords_stretch = niri_geo_to_tex_next * coords_curr_geo;\n  vec3 coords_crop = niri_geo_to_tex_next * coords_next_geo;\n\n  // We can crop if the current window size is smaller than the next window\n  // size. One way to tell is by comparing to 1.0 the X and Y scaling\n  // coefficients in the current-to-next transformation matrix.\n  bool can_crop_by_x = niri_curr_geo_to_next_geo[0][0] <= 1.0;\n  bool can_crop_by_y = niri_curr_geo_to_next_geo[1][1] <= 1.0;\n\n  vec3 coords = coords_stretch;\n  if (can_crop_by_x)\n      coords.x = coords_crop.x;\n  if (can_crop_by_y)\n      coords.y = coords_crop.y;\n\n  vec4 color = texture2D(niri_tex_next, coords.st);\n\n  // However, when we crop, we also want to crop out anything outside the\n  // current geometry. This is because the area of the shader is unspecified\n  // and usually bigger than the current geometry, so if we don't fill pixels\n  // outside with transparency, the texture will leak out.\n  //\n  // When stretching, this is not an issue because the area outside will\n  // correspond to client-side decoration shadows, which are already supposed\n  // to be outside.\n  if (can_crop_by_x && (coords_curr_geo.x < 0.0 || 1.0 < coords_curr_geo.x))\n      color = vec4(0.0);\n  if (can_crop_by_y && (coords_curr_geo.y < 0.0 || 1.0 < coords_curr_geo.y))\n      color = vec4(0.0);\n\n  return color;\n}\n"
    }
}
